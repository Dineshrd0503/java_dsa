package amazontest1;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
//Problem statement
//You are given a network of ‘N’ nodes numbered from 0 to ‘N-1’. This network is represented using an adjacency matrix ‘GRAPH’ of size ‘N’ x ‘N’. You are also given an array ‘INITIAL’ of size ‘M’, which contains the nodes that are initially infected by malware. If there is a direct connection between two nodes and at least one of them is infected by malware, both nodes will be infected by the malware. This malware spread will continue until no more nodes are left, or no more nodes can be infected by this manner.
//
//Let us define a variable ‘INFECTED’ to the total number of infected nodes by the malware spread. Your task is to remove exactly one node from the array ‘INITIAL’ such that it results in the ‘minimum’ value of ‘INFECTED’.
//
//Note :
//
//        1. If GRAPH[X][Y] = 1, then the node ‘X’ is directly connected to a node ‘Y’. Otherwise, there is not a direct connection between ‘X’ and ‘Y’.
//        2. If we remove a node, we must also remove its connections to any other node.
//        3. If multiple such nodes exist that can minimize the value of ‘INFECTED’, you have to find the node with the smallest index.
//        4. All nodes in the array ‘INITIAL’ are unique.
//        5. You have to return the ‘index’ of the node, not the minimum value of the ‘INFECTED’.
//Detailed explanation ( Input/output format, Notes, Images )
//Constraints :
//        1 <= T <= 5
//        2 <= N <= 100
//        0 <= GRAPH[i][j] <= 1,  GRAPH[i][j] == GRAPH[j][i]
//GRAPH[i][i] == 1
//        1 <= M <= N
//0 <= INITIAL[i] < N
//
//Time Limit: 1sec
//Sample Input 1 :
//        1
//        3 2
//        1 0 1
//        0 1 1
//        1 1 1
//        0 2
//Sample Output 1 :
//        2
//Explanation For Sample Input 1 :
//
//The left side graph denotes the initial nodes infected by malware, and the right side indicates the final graph after malware spread.
//If you remove node ‘2’ from the ‘INITIAL’, you will get the minimum value of ‘INFECTED’ that is 1. There is no other way to get a value of ‘INFECTED’ less than 1.
//Sample Input 2 :
//        1
//        3 1
//        1 0 1
//        0 1 1
//        1 1 1
//        0
//Sample Output 2 :
//        0
//Explanation For Sample Input 2 :
//There is only one node in the array ‘INITIAL’. So, we have to remove it.


public class MaximizeMalwareSpread2 {

    public static int minMalwareSpread(ArrayList<ArrayList<Integer>> graph, ArrayList<Integer> initial) {
        int N = graph.size();
        int minInfected = N; // Upper bound on infected; can be at most all nodes
        int resultNode = -1;

        for (int nodeToRemove : initial) {
            // Create a visited set to avoid counting nodes more than once
            boolean[] visited = new boolean[N];
            visited[nodeToRemove] = true; // Remove this node

            // Count infected nodes after removing nodeToRemove
            int currentInfectedCount = 0;

            for (int startNode : initial) {
                if (startNode != nodeToRemove && !visited[startNode]) {
                    currentInfectedCount += dfs(graph, visited, startNode);
                }
            }

            // Check if it leads to a new minimum or a tie
            if (currentInfectedCount < minInfected) {
                minInfected = currentInfectedCount;
                resultNode = nodeToRemove;
            } else if (currentInfectedCount == minInfected && nodeToRemove < resultNode) {
                resultNode = nodeToRemove;
            }
        }

        return resultNode;
    }

    private static int dfs(ArrayList<ArrayList<Integer>> graph, boolean[] visited, int node) {
        visited[node] = true;
        int count = 1; // Count this infected node

        for (int i = 0; i < graph.size(); i++) {
            if (graph.get(node).get(i) == 1 && !visited[i]) {
                count += dfs(graph, visited, i); // Continue DFS for unvisited connected nodes
            }
        }

        return count;
    }

    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
        graph.add(new ArrayList<>(Arrays.asList(1, 1, 0)));
        graph.add(new ArrayList<>(Arrays.asList(1, 1, 0)));
        graph.add(new ArrayList<>(Arrays.asList(0, 0, 1)));
        ArrayList<Integer> initial = new ArrayList<>(Arrays.asList(0, 1));
    }
}
